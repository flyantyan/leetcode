##算法分类:
	贪心算法:M12
	二分查找：
		M34_Search_for_Range.java
 		M35_Search_Insert_Position.java
 		
 		二分查找的实质是根据排序性质丢掉一部分无用数据
 		H33_Search_in_Rotated_Sorted_Array
 		M81. Search in Rotated Sorted Array II
	
	DFS：
		M39_Combination_Sum
		M77. Combinations
		
		
DP:
	53
	M62_Unique_Paths
	M63_Unique_Paths_II
	M64_Minimum_Path_Sum
	M152. Maximum Product Subarray
	
	H115. Distinct Subsequences
	E198. House Robber
	H132_Palindrome_Partitioning_II
	
	M300. Longest Increasing Subsequence
	
	H32. Longest Valid Parentheses
	M322. Coin Change
	H312. Burst Balloons
	M309. Best Time to Buy and Sell Stock with Cooldown
	M221. Maximal Square
Linked List		
	
	
	M92_Reverse_Linked_List_II
	E206_Reverse_Linked_List
	M143. Reorder List
	Linked List Cycle
		141. Linked List Cycle
		142. Linked List Cycle II 
		287. Find the Duplicate Number
		
		
		
二进制加法:
	E67. Add Binary
	M69. Sqrt(x)

ListNode 使用技巧(避免判断)
	ListNode result = new ListNode(0);
	result.next = head ;
	
	return result.next ;
	
	
链表：
	M86_Partition_List
	E83_Remove_Duplicates_from_Sorted_List
	M82_Remove_Duplicates_from_Sorted_ListII
	
	
	Reverse
		E206_Reverse_Linked_List
		M92_Reverse_Linked_List_II
		
Binary Tree:
	遍历：
		94. Binary Tree Inorder Traversal
		
BST:
	95. Unique Binary Search Trees II 
	M98_Validate_Binary_Search_Tree
	99. Recover Binary Search Tree
	
	E100_Same_Tree
	E101. Symmetric Tree
	
	==================BFS================
	E102	Binary Tree Level Order Traversal
	E104	Maximum Depth of Binary Tree
	E107. Binary Tree Level Order Traversal II 
	M103_Binary_Tree_Zigzag_Level_Order_Traversal
	===================

	construct BST
		M108. Convert Sorted Array to Binary Search Tree 
		109. Convert Sorted List to Binary Search Tree
		
	Lever Order Traversal
		199. Binary Tree Right Side View
		
 greedy algorithms:
 	M122. Best Time to Buy and Sell Stock II 
 	
 	
 
 sort
 
 
 
 Graph
 	M332. Reconstruct Itinerary
 	
 	
 	
Sort
	Merge Sort
		327. Count of Range Sum
		315. Count of Smaller Numbers After Self
		
Status
	Easy	Middle	Hard
	18(14)	55(31)	44(13)    72   14+31+13=58    
 	

 permutation 经典算法
 	52. N-Queens II
 	
 正则表达式
 	229. Majority Element II